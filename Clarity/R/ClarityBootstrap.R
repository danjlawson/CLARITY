###############################
#' @title Bootstrap resample data to obtain distribution of predictions under a specified Clarity model
#'
#' @description
#'
#' Takes a Clarity or ClarityScan object and create an ensemble of results for how it predicts a given target matrix. It will use a rank k representation from the Clarity object to generate the best fitting version of the target that has the learned rank k structure.
#' 
#' You can either provide a list of replicated similarity matrices, or some feature data from which bootstrap resamples can be taken from the features to result in a similarity matrix.
#'
#' Each replicated similarity matrix is predicted by the model and summarised appropriately for comparison to data. Uses \code{\link{Clarity_Persistence}} for Persistences and \code{\link{Clarity_Predict}} directly for Residuals.
#'
#' @param clearned either a ClarityScan or Clarity object. If a Clarity object, then residuals will be bootstrapped. If a ClarityScan object then Persistence will be bootstrapped, unless a specific k is given in which case Residuals are again calculated.
#' @param D (default=NULL) An N by L matrix containing N data items and L features. If provided, bootstrapped similarity matrices Ylist are generated by resampling features with replacement.
#' @param Ylist (default=NULL) A list of N by N similarity matrices generated exactly as the original data were generated.
#' @param nbs (default=100) Number of bootstraps to use when D is provided.
#' @param k If specified and clearned is a ClarityScan object, residuals for this k are bootstrapped. (default: NULL, meaning use Persistences)
#' @param distfn Distance function to apply to the bootstrapped data, which should return a similarity or dissimilarity matrix. Default: c_dist, which is as,matrix(dist(x)).
#' @param transform (default: c_Procrust) Transformation 
#' @param seed Seed to reset the random number generator with. Default: NULL, meaning don't reset.
#' @param verbose Whether to print to screen each iteration. Default: FALSE
#' @return A list of length nbs, each containing a matrix
#' @seealso \code{\link{Clarity_Scan}} to run Clarity, \code{\link{Clarity_Extract}} to extract residuals and persistences, \code{\link{plot.ClarityScan}} and \code{\link{plot.Clarity}} for plotting.
#' @examples
#' \donttest{
#' scan=Clarity_Scan(dataraw) ## Core Clarity
#' predmix=Clarity_Predict(datamix,scan)
#' ## Simple feature-based bootstrap for persistences
#' scanbootstrap=c_Bootstrap(scan,D=datarawD)
#'
#' ## Construct a list of externally produced resamples
#' Dreplist=lapply(1:100,function(rep){
#'     datarawD[,sample(1:dim(datarawD)[2],
#'     dim(datarawD)[2], replace = TRUE)]
#' })
#' Yreplist=lapply(Dreplist,c_dist)
#' ## NB Yreplist can have come from a complex resampling scheme
#'
#' ## Bootstrap based on arbitrary resampling scheme
#' scanbootstrap=c_Bootstrap(scan,Ylist=Yreplist)
#'
#' ## Plot bootstrapped persistence chart
#' predplot=plot(predmix,signif=scanbootstrap)
#'
#' ## Similarly for Residuals
#' k10bootstrap=c_Bootstrap(Clarity_Extract(scan,10),
#'                  D=datarawD)
#' predplot=plot(Clarity_Extract(predmix,10),
#'     signif=k10bootstrap)
#' }
#' @export
c_Bootstrap<-function(clearned,
                            D=NULL,
                            Ylist=NULL,
                            nbs=100,
                            k=NULL,
                            distfn=c_dist,
                            transform=c_Procrust,
                            seed=NULL,
                            verbose=FALSE){
    ## If provided with k, bootstraps the residuals. Otherwise bootstrap the persistence.
    if(all(is.null(D)) && all(is.null(Ylist))) stop("Must provide exactly one of D or Ylist")
    if(!all(is.null(D))){
        ## We want to use D to bootstrap the data
        if(!all(is.null(Ylist))) stop("Must provide exactly one of D or Ylist")
    }else{
        ## We want to use Ylist as provided bootstraps of the data
        nbs=length(Ylist)
    }
    if(length(seed)==1) {
        if(verbose)print(paste("Setting seed",seed,"before bootstrap"))
        set.seed(seed)
    }
    if(!is.null(k) && class(clearned)=="ClarityScan"){
        clearned=clearned$scan[[k]]
    }
    bspers=lapply(1:nbs,function(rep){
        if(verbose)cat(paste("... replication",rep,"of",nbs,"\n"))
        if(all(is.null(Ylist))){
            ## Use the provided D
            if(length(seed)==nbs) set.seed(seed[rep])
            xbs=sample(1:dim(D)[2],dim(D)[2],replace=TRUE)
            Dbs=D[,xbs,drop=FALSE]
            Ybs=distfn(Dbs)
        }else Ybs=Ylist[[rep]]
        return(c_BootstrapStructure(clearned=clearned,
                                        Ybs=Ybs,
                                        transform=transform))
    })
    return(bspers)
}

###############################
#' @title Compute Residuals or Persistences on bootstrapped data by scaling them to the data from a learned clarity model
#'
#' @description
#' Given a resampled matrix Ybs, a replicate of Y which was originally used to make a Clarity or ClarityScan object clearned, we:
#' 1. Transform Ybs into YbsT, which "looks as much like Y as possible"
#' 2. Predict YbsT using clearned
#' 3. Compute the residual/persistence structure of this prediction
#'
#' The fit is done with a k that matches that in clearned. If clearned is of class "ClarityScan" then we fit with \code{\link{Clarity_Scan}}, otherwise we fit with \code{\link{Clarity_fixedK}}. We predict the target with \code{\link{Clarity_Predict}}.
#' 
#' @param clearned either a ClarityScan or Clarity object. If a Clarity object, then residuals will be bootstrapped. If a ClarityScan object then Persistence will be bootstrapped, unless a specific k is given in which case Residuals are again calculated.
#' @param Ybs The bootstrapped matrix for which the new model will be learned
#' @param transform (default=c_Procrust) A function to perform a transform of the data to match the target, taking two arguments, (Ybs,target). Default: c_Procrust. 
#' @return A list of residuals if clearned is of class Clarity, or a list of persistences if clearned is of class ClarityScan.
#' @seealso \code{\link{c_Bootstrap}} which is the recommended way to access this code.
#' @export
c_BootstrapStructure=function(clearned,Ybs,
                              transform=c_Procrust){
    if(class(transform)=="function") Ybs=transform(Ybs,clearned$Y)
    if(class(clearned)=="ClarityScan") {
        Ytargetbspred=Clarity_Predict(Ybs,clearned)
#        matlist=lapply(clearned$scan,function(x){
#            c_BootstrapStructure(x,Ybs,transform=FALSE)
#        })
        return(Clarity_Persistence(Ytargetbspred))
    }else if(class(clearned)=="Clarity"){
        ## Rank k fit to the data
        Ytargetbspred=Clarity_Predict(Ybs,clearned)
        return(Clarity_Extract(Ytargetbspred))
    }else stop("Invalid class for clearned")
}


###############################
#' @title Compare Observed to Bootstrap values (Empirical one tailed test)
#'
#' @description
#' Compare an observation (o) with a set of values (x) and report the empirical p value for a one tailed test that o is large compared to x.
#'
#' If the number of observations is low, consider \code{\link{c_CompareNormal}} instead.
#'
#' For a two-tailed test, consider \code{\link{c_CompareEmpiricalTwoTailed}} instead.
#' 
#' @param x the distribution of theoretical or simulated values
#' @param o the observed value
#' @return a p value
#' @seealso \code{\link{c_pval}} in which this function can be used.
#' @export
c_CompareEmpirical=function(x,o){
    sum(c(x, o) >= o)/(length(x) + 1)
}

###############################
#' @title Compare Observed to Bootstrap values (Empirical two tailed test)
#'
#' @description
#' Compare an observation (o) with a set of values (x) and report the empirical p value for a one tailed test that o is far from the mean of x.
#'
#' If the number of observations is low, consider \code{\link{c_CompareNormalTwoTailed}} instead.
#'
#' For a one-tailed test, consider \code{\link{c_CompareEmpirical}} instead.
#' 
#' @param x the distribution of theoretical or simulated values
#' @param o the observed value
#' @return a p value
#' @seealso \code{\link{c_pval}} in which this function can be used.
#' @export
c_CompareEmpiricalTwoTailed=function(x,o){
    min(c(sum(c(x, o) >= o)/(length(x) + 1),
      sum(c(x, o) <= o)/(length(x) + 1)))*2
}

###############################
#' @title Compare Observed to Bootstrap values (Normal approximation two tailed test)
#'
#' @description
#' Compare an observation (o) with a set of values (x) and report the p value for a one tailed test that o is far from the mean of x.
#'
#' If the number of observations is high, consider \code{\link{c_CompareEmpiricalTwoTailed}} instead.
#'
#' For a one-tailed test, consider \code{\link{c_CompareNormal}} instead.
#' 
#' @param x the distribution of theoretical or simulated values
#' @param o the observed value
#' @return a p value
#' @seealso \code{\link{c_pval}} in which this function can be used.
#' @export
c_CompareNormalTwoTailed=function(x,o){
    mu=mean(x)
    sigma=stats::sd(x)
    zscore=(o-mu)/sigma
    p=stats::pt(-abs(zscore),length(x)-1)
    2*p
}

###############################
#' @title Compare Observed to Bootstrap values (Normal approximation one tailed test)
#'
#' @description
#' Compare an observation (o) with a set of values (x) and report the p value for a one tailed test that o is large compared to x. This is usually the most appropriate test in Clarity.
#'
#' If the number of observations is high, consider \code{\link{c_CompareEmpirical}} instead.
#'
#' For a two-tailed test, consider \code{\link{c_CompareNormalTwoTailed}} instead.
#' 
#' @param x the distribution of theoretical or simulated values
#' @param o the observed value
#' @return a p value
#' @seealso \code{\link{c_pval}} in which this function can be used.
#' @export
c_CompareNormal=function(x,o){
    mu=mean(x)
    sigma=stats::sd(x)
    zscore=(o-mu)/sigma
    p=stats::pt(-(zscore),length(x)-1)
    p
}

###############################
#' @title Compare Observed to Bootstrap values 
#'
#' @description
#' 
#' For each element in an observed matrix, extract out the corresponding elements in a list of bootstrapped versions of that matrix. Report on the position of the observed value relative to the bootstrapped values. By default this returns the results in the form of a p-value for a test with the alternative that the observed value is larger than the bootstraps (and the null that it is not)
#'
#'
#' Also note that for normal use you might just want to use \code{\link{plot.Clarity}} or \code{\link{plot.ClarityScan}}, both of which use this function for you.
#'
#' @param testbs A list of bootstrapped matrices as returned from \code{\link{c_Bootstrap}}
#' @param obs Either a Clarity object (for comparing residuals), A ClarityScan object (for comparing persistences) or a matrix of observed values (absolute residuals or persistences, respectively)
#' @param comparison (default=\code{\link{c_CompareNormal}}) a function to score the observed value relative to the bootstraped values. The default performs a one-tailed test that the observed value is large compared to the bootstrapped values, using a normal approximation of the distributions. This is usually the best choice, but \code{\link{c_CompareNormalTwoTailed}} , \code{\link{c_CompareEmpirical}} and \code{\link{c_CompareEmpiricalTwoTailed}} can be used instead.
#' 
#' @return A matrix of the same shape as obs, containing the result of comparison applied to each element
#' @seealso \code{\link{c_Bootstrap}} for making bootstraps. For plotting, \code{\link{plot.Clarity}} or \code{\link{plot.ClarityScan}} call this function for you.  \code{\link{Clarity_Persistence}} for extracting persistence or  \code{\link{Clarity_Extract}} to extract residuals.
#' @examples
#' \donttest{
#' scan=Clarity_Scan(dataraw) ## Core Clarity
#' predmix=Clarity_Predict(datamix,scan) ## Core prediction
#' 
#' ## Bootstrap persistences:
#' scanbootstrap=c_Bootstrap(scan,target=datamix,D=datarawD)
#' ## Extract observed persistences
#' P=Clarity_Persistence(predmix)
#' ## Compute pvalues
#' pvals=c_pval(scanbootstrap,P)
#' ## pvals is a matrix of dimension N by K
#' signif=pvals<0.01
#' ## signif is a logical matrix of dimension N by K
#' 
#' ## Similarly for residuals:
#' ## Bootstrap residuals
#' k10bootstrap=c_Bootstrap(Clarity_Extract(scan,10),
#'                                target=datamix,
#'                                D=datarawD)
#' ## Extract observed residuals
#' k10residuals=Clarity_Extract(predmix,k=10)
#' ## Compute Pvals
#' residualpvals=c_pval(k10bootstrap,k10residuals,
#'                         population="bestcol")
#' residualsignif=residualpvals<0.01
#'
#' }
#' @export
c_pval=function(testbs,obs,
                comparison=c_CompareNormal ) {
    if(class(obs)=="Clarity"){
        obs=Clarity_Extract(obs,diag=0)
    }else if(class(obs)=="ClarityScan"){
        obs=Clarity_Persistence(obs)
    }
    pvals=t(sapply(1:dim(obs)[1],function(i){
        sapply(1:dim(obs)[2],function(j){
            b1=sapply(testbs,function(x)x[i,j])
            comparison(b1,obs[i,j])
        })
    }))
    if(class(pvals)=="matrix") {
        colnames(pvals)=NULL
        rownames(pvals)=rownames(obs)
    }else{
        names(pvals)=rownames(obs)
    }
    return(list(obs=obs,
                testbs=testbs,
                pvals=pvals))
}

